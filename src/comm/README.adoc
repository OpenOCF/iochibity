= iotivity networking

== threading

camessagehandler:
static CAQueueingThread_t g_sendThread  (routine is CASendThreadProcess)
   calls camessagehandler::CAProcessSendData
   eventually ends up in caipserver::CAIPSendData

static CAQueueingThread_t g_receiveThread - this is not currently used (see SINGLE_HANDLE???)

caipadapter0:
static CAQueueingThread_t *g_sendQueueHandle (routine is CAIPSendDataThread)

cainterfacecontroller:
static CAQueueingThread_t g_networkChangeCallbackThread;


== "global" data

These are named with g_ prefix but they are just static (file-scoped) vars.

cainterfacecontroller:
* static CAConnectivityHandler_t *g_adapterHandler = NULL; // array of control structs
* static size_t g_numberOfAdapters = 0;
* static CANetworkPacketReceivedCallback g_networkPacketReceivedCallback = NULL;
* static CAErrorHandleCallback g_errorHandleCallback = NULL;
* static struct CANetworkCallback_t *g_networkChangeCallbackList = NULL;
* static CAQueueingThread_t g_networkChangeCallbackThread; (if not single thread)

caipadapter0:

* static CAQueueingThread_t *g_sendQueueHandle = NULL;
* static u_arraylist_t *g_ownIpEndpointList = NULL;
* static CANetworkPacketReceivedCallback g_networkPacketCallback = NULL;
* static CAAdapterChangeCallback g_networkChangeCallback = NULL;
* static CAErrorHandleCallback g_udpErrorCB = NULL;

caipserver0:

* CAIPErrorHandleCallback g_ipErrorHandler = NULL;
* CAIPPacketReceivedCallback g_packetReceivedCallback

caipnwmonitor0:

* oc_mutex g_networkMonitorContextMutex = NULL;
*  g_netInterfaceList  (g_nw_addresses)
* struct CAIPCBData_t *g_adapterCallbackList = NULL;


== thread queues

cainterfacecontroller::CAInitializeAdapters calls caqueueingthread::CAQueueingThreadInitialize

this initializes static cainterfacecontroller::g_networkChangeCallbackThread

the task it passes is cainterfacecontroller::CANetworkChangeCallbackThreadProcesso

static cainterfacecontroller::CAAdapterChangedCallback:

* for each cb in static cainterfacecontroller::g_networkChangeCallbackList:
** create a CANetworkCallbackThreadInfo_t containing chg callback
** call CAQueueingThreadAddData

CAQueueingThreadAddData:
* create a message
* add it to queue (under mutex)
* cond_signal, which will wake up CANetworkCallbackThreadInfo

CANetworkCallbackThreadInfo is called with threadData, it applies the contained CB to the transport adapter and status

== event handling
We have two static CAReceivedPacketCallback implementations, one in
cainterfacecontroller and one in camessagehandler.  We rename to
disambiguate.

static cainterfacecontroller::ifc_CAReceivedPacketCallback is stored in
       static caipadapter0::g_networkPacketCallback
       by CAInitializeUDP (was CAInitializeIP)

caipadapter0::g_networkPacketCallback is called by
    static caipadapter0::CAIPPacketReceivedCB ONLY

IOW  CAIPPacketReceivedCB calls cainterfacecontroller::ifc_CAReceivedPacketCallback

caipserver0::CAIPSetPacketReceiveCallback stores CAIPPacketReceivedCB
in caipserver0::g_udpPacketRecdCB, which is called by caipserver_posix::CAReceiveMessage

static cainterfacecontroller::ifc_CAReceivedPacketCallback
	calls local static g_networkPacketReceivedCallback
	which holds camessagehandler::mh__CAReceivedPacketCallback
	nothing else calls g_networkPacketReceivedCallback

static camessagehandler::mh_CAReceivedPacketCallback is stored in
       cainterfacecontroller::g_networkPacketReceivedCallback
       by camessagehandler::CAInitializeMessageHandler


Summary:

server_<transport>::CASelectReturned
=>server_<transport>::CAReceiveMessage
==> g_packetReceivedCallback(caipserver0) (caipadapter0:CA<transport>PacketReceivedCB) (no effect for UDP)
===> g_networkPacketCallback(caipadapter0) (ifc_CAReceivedPacketCallback) (no effect)
====> g_networkPacketReceivedCallback(cainterfacecontroller) (mh_CAReceivedPacketCallback)

So ultimately the transport server's recv msg method calls the message handler's handler

The ultimate handling (mh_CAReceivedPacketCallback) is same for both transports

CAUDPPacketReceivedCB, CATCPPacketReceivedCB are different

UDP coould call mh_CAReceivedPacketCallback directly from CASelectReturned


couldn't we make this more complex?



is passed to
       cainterfacecontroller:::CASetPacketReceivedCallback
        by camessagehandler::CAInitializeMessageHandler

caconnectivitymanager::CAInitialize
=>camesssagehandler::CAInitializeMessageHandler
==>cainterfacecontroller::CASetPacketReceivedCallback(camesssagehandler::_CAReceivedPacketCallback)
            which sets cainterfacecontroller::g_networkPacketReceivedCallback

g_networkPacketReceivedCallback is called by cainterfacecontroller::CAReceivedPacketCallback ONLY

== structure

The structure is vaguely object-oriented: "adapter" is a kind of
abstract class whose methods must be implemented by subclasses, of
which there is one per transport (udp, tcp, bt classic, ble, etc.).

The adapter methods are declared in caadapterinterface.c.

But "interface" is a somewhat infelicitous term insofar as it suggests
the notion of "network interface", which is a completely different
thing.  "Adapter" is also problematic, for the same reason: it
suggests "network adapter", i.e. NIC.

What caadapterinterface actually specifics is a network services
protocol.  Implementations are transport-specific, so instead of
calling them adapters we call them handlers. (?)

TODO: in transports we have e.g. CAInitialize<Transport>, but
also CA<Transport>SetPacketReceivedCallback. Unify these.


* CT_ADAPTER_x : what this really means is CT_TRANSPORT_x.
** CT_ADAPTER_IP : means UDP transport
** CT_ADAPTER_GATT_BTLE : GATT is a profile; the transport is ATT (Attribute Protocol)
** CT_ADAPTER_RFCOMM_BTEDR : RFCOMM is a transport protocol (http://www.amd.e-technik.uni-rostock.de/ma/gol/lectures/wirlec/bluetooth_info/rfcomm.html#RFCOMM Overview/Service_
** CT_ADAPTER_TCP : obviously TCP is a transport protocol
** CT_ADAPTER_NFC : not sure, assuming this really refers to a transport protocol, at least roughly

NOTE: this flags from OCConnectivityType are mirrored by OC_ consts from OCTransportAdapter

Then we have OC_IP_USE_V4 and OC_IP_USE_V6 (and their CT_
counterparts).  These are obviously about the network protocol layer:

* xx_IP_USE_Vn => xx_NETWORK_PROTOCOL_IPVn

TCP Link layer (OSI Data Link + Physical layer):

The assumption seems to be that this will be IPv6 over 802.11 (WiFI).

IPv6 over 802.15.4: 6LoWPAN (https://tools.ietf.org/html/rfc4919, https://tools.ietf.org/html/rfc4944, https://tools.ietf.org/html/rfc6282, https://tools.ietf.org/html/rfc6775)

IPv6 over BLE:  https://tools.ietf.org/html/rfc7668) Note that this uses 6LoWPAN.

In general, in Iotivity the networking protocol is implied by the
transport protocol; in the specific case of UDP and TCP, the implied
networking protocol is IP, but since there are two versions of IP we
need to say which.

Note that the constants are inconsistent; we have e.g. we have
CT_ADAPTER_TCP, but we have no CT_ADAPTER_UDP. Instead we have
CT_ADAPTER_IP, which covers both IPv4 and IPv6, including 6LoWPAN.

    // NOTE: OCDoResource needs a DevAddr and a ConnectivityType,
    // giving redundant networking params.  Why? Maybe so
    // ConnectivityType can be used when DevAddr is NULL (multicast)?

    // // OCDevAddr
    // native public DeviceAddress   coAddress(); // ??

    // public  DeviceAddress          getCoAddress() {
    // 	if (_destination == null) {
    // 	    return coAddress();
    // 	} else {
    // 	    return _destination;
    // 	}
    // }

    // OCDoResources takes an OCConnectivityType arg, in addition to
    // the OCDevAddr arg which contains the same type of data as
    // OCConnectivityType.

    // Why is this? Maybe: if the OCDevAddr* arg is NULL, it's a multicast,
    // and can use the OCConnectivityType params.  Otherwise, it's a
    // unicast targeting the OCDevAddr, whose parameters should be
    // used.

    // If that's right, these should pull data from the device address
    // if we have one, otherwise from connectivityType

    // also OCClientResponse contains an OCConnectivityType member.

=== issues

api/ seems to be the public api, containing:
    common.h
    cainterface.h
    casecurityinterface.h

api/common.h - do something about this

comm/common/cacommonutil.h - contains only VERIFY_x macros; move to src/macros.h?
