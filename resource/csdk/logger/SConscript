Import('env')
import os
import build.utils

print "CSDK/LOGGER"

env.AppendUnique(CPPPATH = ['#resource/c_common',
                            '#resource/csdk/security/ocsecurity',
                            '#resource/csdk/stack'])

if env.get('TARGET_OS') in ['arduino']:
	env.AppendUnique(CPPPATH = [os.path.join(env.get('BUILD_DIR'), 'resource/c_common')])
if env.get('TARGET_OS') == 'tizen':
	env.AppendUnique(LIBPATH = [env.get('BUILD_DIR')])
# else:
# 	env.AppendUnique(LIBPATH = [os.path.join(env.get('BUILD_DIR'), 'logger')])

env.PrependUnique(LIBS = ['ocsrm'])
env.AppendUnique(LIBPATH = [os.path.join(env.get('BUILD_SYSROOT'), 'security')])

local_env = env.Clone()

######################################################################
# Source files and Targets
######################################################################

#TODO work-around: at the moment if an Arduino build is done the logger.c file
# ends up using C++ such as for the arduino Time Library, Serial, etc.
# Therefore we copy it to a .cpp name so it is compiled correctly.

if env.get('TARGET_OS') in ['arduino']:
	Command("logger.cpp", "logger.c", Copy("$TARGET", "$SOURCE"))
	logger_src = ['logger.cpp']
else:
	logger_src = ['logger.c']

loggerlib = env.StaticLibrary('logger', logger_src)
# build.utils.install_lib(env, loggerlib, 'logger')
build.utils.install_headers(env,  ## .get('INSTALL_SYSROOT') + '/include',
			     ['logger.h', 'logger_types.h'],
                             '',
                             'headers')
