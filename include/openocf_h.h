typedef enum {
    /* Result code - START HERE */
    CA_STATUS_OK = 0,               /**< Success */
    CA_STATUS_INVALID_PARAM,        /**< Invalid Parameter */
    CA_ADAPTER_NOT_ENABLED,         /**< Adapter is not enabled */
    CA_SERVER_STARTED_ALREADY,      /**< Server is started already */
    CA_SERVER_NOT_STARTED,          /**< Server is not started */
    CA_DESTINATION_NOT_REACHABLE,   /**< Destination is not reachable */
    CA_SOCKET_OPERATION_FAILED,     /**< Socket operation failed */
    CA_SEND_FAILED,                 /**< Send request failed */
    CA_RECEIVE_FAILED,              /**< Receive failed */
    CA_MEMORY_ALLOC_FAILED,         /**< Memory allocation failed */
    CA_REQUEST_TIMEOUT,             /**< Request is Timeout */
    CA_DESTINATION_DISCONNECTED,    /**< Destination is disconnected */
    CA_NOT_SUPPORTED,               /**< Not supported */
    CA_STATUS_NOT_INITIALIZED,      /**< Not Initialized*/
    CA_DTLS_AUTHENTICATION_FAILURE, /**< Decryption error in DTLS */
    CA_CONTINUE_OPERATION,          /**< Error happens but current operation should continue */
    CA_HANDLE_ERROR_OTHER_MODULE,   /**< Error happens but it should be handled in other module */
    CA_STATUS_FAILED =255           /**< Failure */
    /* Result code - END HERE */
}CAResult_t;
#include "coap/pdu.h"
#include "coap/coap_list.h"
typedef enum {
    CA_MSG_CONFIRM = 0,  /**< confirmable message (requires ACK/RST) */
    CA_MSG_NONCONFIRM,   /**< non-confirmable message (one-shot message) */
    CA_MSG_ACKNOWLEDGE,  /**< used to acknowledge confirmable messages */
    CA_MSG_RESET         /**< used to indicates not-interested or error (lack of context)in
                                                  received messages */
}CAMessageType_t;
#if (__STDC_VERSION__ >= 201112L) /* C11 */ && defined(__STDC__)
#include <assert.h>
#endif
#define HAVE_STDBOOL_H 1
#if defined(HAVE_STDBOOL_H)
#include <stdbool.h>
#endif
#define HAVE__BOOL 1
#if !(defined(__cplusplus)) && !defined(HAVE__BOOL) && !(defined(HAVE_STDBOOL_H))
#   define _Bool signed char
#endif
#if defined(__cplusplus) && !defined(HAVE__BOOL) && !(defined(HAVE_STDBOOL_H))
typedef bool _Bool;
#endif
#if !(defined(HAVE_STDBOOL_H))
# define bool _Bool
#endif
typedef char *CAToken_t;
#include <stdint.h>
typedef enum {
    CA_INVALID_ID = (1 << 0),   /**< Invalid ID */
    CA_COAP_ID = (1 << 1)       /**< COAP ID */
}CATransportProtocolID_t;
#define CA_MAX_HEADER_OPTION_DATA_LENGTH 1024
typedef struct {
    CATransportProtocolID_t protocolID;                     /**< Protocol ID of the Option */
    uint16_t optionID;                                      /**< The header option ID which will be
                                                            added to communication packets */
    uint16_t optionLength;                                  /**< Option Length **/
    char optionData[CA_MAX_HEADER_OPTION_DATA_LENGTH];      /**< Optional data values**/
}CAHeaderOption_t;
typedef uint8_t *CAPayload_t;
typedef enum {
    CA_FORMAT_UNDEFINED = 0,            /**< Undefined enoding format */
    CA_FORMAT_TEXT_PLAIN,
    CA_FORMAT_APPLICATION_LINK_FORMAT,
    CA_FORMAT_APPLICATION_XML,
    CA_FORMAT_APPLICATION_OCTET_STREAM,
    CA_FORMAT_APPLICATION_RDF_XML,
    CA_FORMAT_APPLICATION_EXI,
    CA_FORMAT_APPLICATION_JSON,
    CA_FORMAT_APPLICATION_CBOR,
    CA_FORMAT_APPLICATION_VND_OCF_CBOR,
    CA_FORMAT_UNSUPPORTED
}CAPayloadFormat_t;
typedef char *CAURI_t;
#define CA_MAX_IDENTITY_SIZE (37)
#define CA_MAX_ENDPOINT_IDENTITY_LEN  CA_MAX_IDENTITY_SIZE
typedef struct {
    uint16_t id_length;
    unsigned char id[CA_MAX_ENDPOINT_IDENTITY_LEN];
}CARemoteId_t;
typedef enum {
    CA_REQUEST_DATA = 1,
    CA_RESPONSE_DATA,
    CA_ERROR_DATA,
    CA_RESPONSE_FOR_RES
}CADataType_t;
typedef struct {
    CAMessageType_t type;       /**< Qos for the request */
#ifdef ROUTING_GATEWAY
    bool skipRetransmission;    /**< Will not attempt retransmission even if type is CONFIRM.
                                     Required for packet forwarding */
#endif
    uint16_t messageId;         /**< Message id.
                                 * if message id is zero, it will generated by CA inside.
                                 * otherwise, you can use it */
    CAToken_t token;            /**< Token for CA */
    uint8_t tokenLength;        /**< token length */
    CAHeaderOption_t *options;  /** Header Options for the request */
    uint8_t numOptions;         /**< Number of Header options */
    CAPayload_t payload;        /**< payload of the request  */
    size_t payloadSize;         /**< size in bytes of the payload */
    CAPayloadFormat_t payloadFormat;    /**< encoding format of the request payload */
    CAPayloadFormat_t acceptFormat;     /**< accept format for the response payload */
    uint16_t payloadVersion;    /**< version of the payload */
    uint16_t acceptVersion;     /**< expected version for the response payload */
    CAURI_t resourceUri;        /**< Resource URI information **/
    CARemoteId_t identity;      /**< endpoint identity */
    CADataType_t dataType;      /**< data type */
}CAInfo_t;
typedef struct {
    CAResult_t result;  /**< CA API request result  */
    CAInfo_t info;      /**< message information such as token and payload data
                             helpful to identify the error */
}CAErrorInfo_t;
typedef struct CAEndpoint_s CAEndpoint_s;
typedef enum {
    CA_DEFAULT_ADAPTER = 0,

    // value zero indicates discovery
    CA_ADAPTER_IP            = (1 << 0),   // IPv4 and IPv6, including 6LoWPAN
    CA_ADAPTER_GATT_BTLE     = (1 << 1),   // GATT over Bluetooth LE
    CA_ADAPTER_RFCOMM_BTEDR  = (1 << 2),   // RFCOMM over Bluetooth EDR

#ifdef RA_ADAPTER
    CA_ADAPTER_REMOTE_ACCESS = (1 << 3),   // Remote Access over XMPP.
#endif

    CA_ADAPTER_TCP           = (1 << 4),   // CoAP over TCP
    CA_ADAPTER_NFC           = (1 << 5),   // NFC Adapter

    CA_ALL_ADAPTERS          = 0xffffffff
}CATransportAdapter_t;
typedef enum {
    CA_DEFAULT_FLAGS = 0,

    // Insecure transport is the default (subject to change)
    CA_SECURE          = (1 << 4),   // secure the transport path
    // IPv4 & IPv6 autoselection is the default
    CA_IPV6            = (1 << 5),   // IP adapter only
    CA_IPV4            = (1 << 6),   // IP adapter only
    // Indication that a message was received by multicast.
    CA_MULTICAST       = (1 << 7),
    // Link-Local multicast is the default multicast scope for IPv6.
    // These correspond in both value and position to the IPv6 address bits.
    CA_SCOPE_INTERFACE = 0x1, // IPv6 Interface-Local scope
    CA_SCOPE_LINK      = 0x2, // IPv6 Link-Local scope (default)
    CA_SCOPE_REALM     = 0x3, // IPv6 Realm-Local scope
    CA_SCOPE_ADMIN     = 0x4, // IPv6 Admin-Local scope
    CA_SCOPE_SITE      = 0x5, // IPv6 Site-Local scope
    CA_SCOPE_ORG       = 0x8, // IPv6 Organization-Local scope
    CA_SCOPE_GLOBAL    = 0xE, // IPv6 Global scope
}CATransportFlags_t;
#if defined(RA_ADAPTER)
#define MAX_ADDR_STR_SIZE (256)
#endif
#if !(defined(RA_ADAPTER))
#define MAX_ADDR_STR_SIZE (66)
#endif
#define MAX_ADDR_STR_SIZE_CA MAX_ADDR_STR_SIZE
struct CAEndpoint_s {
    CATransportAdapter_t    adapter;    // adapter type
    CATransportFlags_t      flags;      // transport modifiers
    uint16_t                port;       // for IP
    char                    addr[MAX_ADDR_STR_SIZE_CA]; // address for all
    uint32_t                ifindex;    // usually zero for default interface
    char                    remoteId[CA_MAX_IDENTITY_SIZE]; // device ID of remote device
#if defined (ROUTING_GATEWAY) || defined (ROUTING_EP)
    char                    routeData[MAX_ADDR_STR_SIZE_CA]; /**< GatewayId:ClientId of
                                                                    destination. **/
#endif
};
typedef struct CAEndpoint_s CAEndpoint_t;
typedef void(*CAErrorCallback)(const CAEndpoint_t *object,const CAErrorInfo_t *errorInfo);
typedef CAResult_t(*CAHandshakeErrorCallback)(const CAEndpoint_t *object,const CAErrorInfo_t *errorInfo);
typedef enum {
    CA_INTERFACE_DOWN,   /**< Connection is not available */
    CA_INTERFACE_UP    /**< Connection is Available */
}CANetworkStatus_t;
typedef void(*CANetworkMonitorCallback)(const CAEndpoint_t *info,CANetworkStatus_t status);
typedef enum {
    CA_GET = 1, /**< GET Method  */
    CA_POST,    /**< POST Method */
    CA_PUT,     /**< PUT Method */
    CA_DELETE   /**< DELETE Method */
}CAMethod_t;
typedef struct {
    CAMethod_t method;  /**< Name of the Method Allowed */
    CAInfo_t info;      /**< Information of the request. */
    bool isMulticast;   /**< is multicast request */
}CARequestInfo_t;
typedef void(*CARequestCallback)(const CAEndpoint_t *object,const CARequestInfo_t *requestInfo);
typedef enum {
    /* Response status code - START HERE */
    CA_EMPTY = 0,                           /**< Empty */
    CA_CREATED = 201,                       /**< Created */
    CA_DELETED = 202,                       /**< Deleted */
    CA_VALID = 203,                         /**< Valid */
    CA_CHANGED = 204,                       /**< Changed */
    CA_CONTENT = 205,                       /**< Content */
    CA_CONTINUE = 231,                      /**< Continue */
    CA_BAD_REQ = 400,                       /**< Bad Request */
    CA_UNAUTHORIZED_REQ = 401,              /**< Unauthorized Request */
    CA_BAD_OPT = 402,                       /**< Bad Option */
    CA_FORBIDDEN_REQ = 403,                 /**< Forbidden Request */
    CA_NOT_FOUND = 404,                     /**< Not found */
    CA_METHOD_NOT_ALLOWED = 405,            /**< Method Not Allowed */
    CA_NOT_ACCEPTABLE = 406,                /**< Not Acceptable */
    CA_REQUEST_ENTITY_INCOMPLETE = 408,     /**< Request Entity Incomplete */
    CA_REQUEST_ENTITY_TOO_LARGE = 413,      /**< Request Entity Too Large */
    CA_INTERNAL_SERVER_ERROR = 500,         /**< Internal Server Error */
    CA_BAD_GATEWAY = 502,
    CA_SERVICE_UNAVAILABLE = 503,           /**< Server Unavailable */
    CA_RETRANSMIT_TIMEOUT = 504,            /**< Retransmit timeout */
    CA_PROXY_NOT_SUPPORTED = 505            /**< Proxy not enabled to service a request */
    /* Response status code - END HERE */
}CAResponseResult_t;
typedef struct {
    CAResponseResult_t result;  /**< Result for response by resource model */
    CAInfo_t info;              /**< Information of the response */
    bool isMulticast;
}CAResponseInfo_t;
typedef void(*CAResponseCallback)(const CAEndpoint_t *object,const CAResponseInfo_t *responseInfo);
#if defined(HAVE_WINSOCK2_H)
#define OC_SOCKET_ERROR      SOCKET_ERROR
#endif
#if !(defined(HAVE_WINSOCK2_H))
#define OC_SOCKET_ERROR      (-1)
#endif
#if defined(HAVE_WINSOCK2_H)
#define OC_INVALID_SOCKET    INVALID_SOCKET
#endif
#if !(defined(HAVE_WINSOCK2_H))
#define OC_INVALID_SOCKET    (-1)
#endif
#if defined(HAVE_WINSOCK2_H)
#define CASocketFd_t SOCKET
#endif
#if !(defined(HAVE_WINSOCK2_H))
#define CASocketFd_t int
#endif
#define UUID_PREFIX "uuid:"
#define SUBJECT_PREFIX "CN=" UUID_PREFIX
#define COAP_MEDIATYPE_APPLICATION_VND_OCF_CBOR 10000 // application/vnd.ocf+cbor
#define OCF_ACCEPT_CONTENT_FORMAT_VERSION 2049
#define OCF_CONTENT_FORMAT_VERSION 2053
#define DEFAULT_VERSION_VALUE 2048
typedef struct {
    /** Platform ID.*/
    char *platformID;

    /** Manufacturer name.*/
    char *manufacturerName;

    /** Manufacturer URL for platform property.*/
    char *manufacturerUrl;

    /** Model number.*/
    char *modelNumber;

    /** Manufacturer date.*/
    char *dateOfManufacture;

    /** Platform version.*/
    char *platformVersion;

    /** Operating system version.*/
    char *operatingSystemVersion;

    /** HW version.*/
    char *hardwareVersion;

    /** FW version.*/
    char *firmwareVersion;

    /** Platform support URL.*/
    char *supportUrl;

    /** System time.*/
    char *systemTime;

}OCPlatformInfo;
typedef enum {
    /** value zero indicates discovery.*/
    OC_DEFAULT_ADAPTER = 0,
    /* CA_DEFAULT_ADAPTER = 0, */

    /** IPv4 and IPv6, including 6LoWPAN.*/
    OC_ADAPTER_IP           = (1 << 0),
    /* CA_ADAPTER_IP            = (1 << 0),   // IPv4 and IPv6, including 6LoWPAN */

    /** GATT over Bluetooth LE.*/
    OC_ADAPTER_GATT_BTLE    = (1 << 1),
    /* CA_ADAPTER_GATT_BTLE     = (1 << 1),   // GATT over Bluetooth LE */

    /** RFCOMM over Bluetooth EDR.*/
    OC_ADAPTER_RFCOMM_BTEDR = (1 << 2),
    /* CA_ADAPTER_RFCOMM_BTEDR  = (1 << 2),   // RFCOMM over Bluetooth EDR */

#ifdef RA_ADAPTER
    /**Remote Access over XMPP.*/
    OC_ADAPTER_REMOTE_ACCESS = (1 << 3),
    /* CA_ADAPTER_REMOTE_ACCESS = (1 << 3),   // Remote Access over XMPP. */
#endif

    /** CoAP over TCP.*/
    OC_ADAPTER_TCP           = (1 << 4),
    /* CA_ADAPTER_TCP           = (1 << 4),   // CoAP over TCP */

    /** NFC Transport for Messaging.*/
    OC_ADAPTER_NFC           = (1 << 5),
    /* CA_ADAPTER_NFC           = (1 << 5),   // NFC Adapter */

    OC_ALL_ADAPTERS          = 0xffffffff
    /* CA_ALL_ADAPTERS          = 0xffffffff */
}OCTransportAdapter;
typedef enum {
    /** default flag is 0*/
    OC_DEFAULT_FLAGS = 0,
    /* CA_DEFAULT_FLAGS = 0, */

    /** Insecure transport is the default (subject to change).*/
    /** secure the transport path*/
    OC_FLAG_SECURE     = (1 << 4),
    // Insecure transport is the default (subject to change)
    /* CA_SECURE          = (1 << 4),   // secure the transport path */

    /** IPv4 & IPv6 auto-selection is the default.*/
    /** IP & TCP adapter only.*/
    OC_IP_USE_V6       = (1 << 5),
    /* CA_IPV6            = (1 << 5),   // IP adapter only */

    /** IP & TCP adapter only.*/
    OC_IP_USE_V4       = (1 << 6),
    /* CA_IPV4            = (1 << 6),   // IP adapter only */

    /** Multicast only.*/
    OC_MULTICAST       = (1 << 7),
    // Indication that a message was received by multicast.
    /* CA_MULTICAST       = (1 << 7), */

    /** Link-Local multicast is the default multicast scope for IPv6.
     *  These are placed here to correspond to the IPv6 multicast address bits.*/

    /** IPv6 Interface-Local scope (loopback).*/
    OC_SCOPE_INTERFACE = 0x1,
    /* CA_SCOPE_INTERFACE = 0x1, // IPv6 Interface-Local scope */

    /** IPv6 Link-Local scope (default).*/
    OC_SCOPE_LINK      = 0x2,
    /* CA_SCOPE_LINK      = 0x2, // IPv6 Link-Local scope (default) */

    /** IPv6 Realm-Local scope. */
    OC_SCOPE_REALM     = 0x3,
    /* CA_SCOPE_REALM     = 0x3, // IPv6 Realm-Local scope */

    /** IPv6 Admin-Local scope. */
    OC_SCOPE_ADMIN     = 0x4,
    /* CA_SCOPE_ADMIN     = 0x4, // IPv6 Admin-Local scope */

    /** IPv6 Site-Local scope. */
    OC_SCOPE_SITE      = 0x5,
    /* CA_SCOPE_SITE      = 0x5, // IPv6 Site-Local scope */

    /** IPv6 Organization-Local scope. */
    OC_SCOPE_ORG       = 0x8,
    /* CA_SCOPE_ORG       = 0x8, // IPv6 Organization-Local scope */

    /**IPv6 Global scope. */
    OC_SCOPE_GLOBAL    = 0xE,
    /* CA_SCOPE_GLOBAL    = 0xE, // IPv6 Global scope */

}OCTransportFlags;
#define CA_IPFAMILY_MASK (CA_IPV6|CA_IPV4)
#define CA_SCOPE_MASK 0xf     // mask scope bits above
#define MAX_IDENTITY_SIZE (37)
typedef struct {
    /** adapter type.*/
    OCTransportAdapter      adapter;

    /** transport modifiers.*/
    OCTransportFlags        flags;

    /** for IP.*/
    uint16_t                port;

    /** address for all adapters.*/
    char                    addr[MAX_ADDR_STR_SIZE];

    /** usually zero for default interface.*/
    uint32_t                ifindex;

    /** destination GatewayID:ClientId.*/
    char                    routeData[MAX_ADDR_STR_SIZE];

    /** device ID of remote.*/
    char                    remoteId[MAX_IDENTITY_SIZE];

}OCDevAddr;
typedef enum {
    /** use when defaults are ok. */
    CT_DEFAULT = 0,

    /** IPv4 and IPv6, including 6LoWPAN.*/
    CT_ADAPTER_IP           = (1 << 16),

    /** GATT over Bluetooth LE.*/
    CT_ADAPTER_GATT_BTLE    = (1 << 17),

    /** RFCOMM over Bluetooth EDR.*/
    CT_ADAPTER_RFCOMM_BTEDR = (1 << 18),

#ifdef RA_ADAPTER
    /** Remote Access over XMPP.*/
    CT_ADAPTER_REMOTE_ACCESS = (1 << 19),
#endif
    /** CoAP over TCP.*/
    CT_ADAPTER_TCP     = (1 << 20),

    /** NFC Transport.*/
    CT_ADAPTER_NFC     = (1 << 21),

    /** Insecure transport is the default (subject to change).*/

    /** secure the transport path.*/
    CT_FLAG_SECURE     = (1 << 4),

    /** IPv4 & IPv6 autoselection is the default.*/

    /** IP adapter only.*/
    CT_IP_USE_V6       = (1 << 5),

    /** IP adapter only.*/
    CT_IP_USE_V4       = (1 << 6),

    /** Link-Local multicast is the default multicast scope for IPv6.
     * These are placed here to correspond to the IPv6 address bits.*/

    /** IPv6 Interface-Local scope(loopback).*/
    CT_SCOPE_INTERFACE = 0x1,

    /** IPv6 Link-Local scope (default).*/
    CT_SCOPE_LINK      = 0x2,

    /** IPv6 Realm-Local scope.*/
    CT_SCOPE_REALM     = 0x3,

    /** IPv6 Admin-Local scope.*/
    CT_SCOPE_ADMIN     = 0x4,

    /** IPv6 Site-Local scope.*/
    CT_SCOPE_SITE      = 0x5,

    /** IPv6 Organization-Local scope.*/
    CT_SCOPE_ORG       = 0x8,

    /** IPv6 Global scope.*/
    CT_SCOPE_GLOBAL    = 0xE,
}OCConnectivityType;
#define CT_ADAPTER_SHIFT 16
#define CT_MASK_FLAGS 0xFFFF
#define CT_MASK_ADAPTER 0xFFFF0000
#define WITH_PRESENCE
typedef enum {
    OC_REST_NOMETHOD       = 0,

    /** Read.*/
    OC_REST_GET            = (1 << 0),

    /** Write.*/
    OC_REST_PUT            = (1 << 1),

    /** Update.*/
    OC_REST_POST           = (1 << 2),

    /** Delete.*/
    OC_REST_DELETE         = (1 << 3),

    /** Register observe request for most up date notifications ONLY.*/
    OC_REST_OBSERVE        = (1 << 4),

    /** Register observe request for all notifications, including stale notifications.*/
    OC_REST_OBSERVE_ALL    = (1 << 5),

#ifdef WITH_PRESENCE
    /** Subscribe for all presence notifications of a particular resource.*/
    OC_REST_PRESENCE       = (1 << 7),
#endif
    /** Allows OCDoResource caller to do discovery.*/
    OC_REST_DISCOVER       = (1 << 8)
}OCMethod;
typedef enum {
    OC_CLIENT = 0,
    OC_SERVER,
    OC_CLIENT_SERVER,
    OC_GATEWAY          /**< Client server mode along with routing capabilities.*/
}OCMode;
#define OC_MASK_RESOURCE_SECURE    (OC_NONSECURE | OC_SECURE)
typedef enum {
    /** Make no more calls to the callback and call the OCClientContextDeleter for this callback */
    OC_STACK_DELETE_TRANSACTION = 0,
    /** Keep this callback registered and call it if an apropriate event occurs */
    OC_STACK_KEEP_TRANSACTION,
    OC_STACK_KEEP_RESPONSE	/* GAR client responsible for freeing response */
}OCStackApplicationResult;
typedef enum {
    OC_EH_OK = 0,
    OC_EH_ERROR,
    OC_EH_SLOW,
    OC_EH_RESOURCE_CREATED = 201,
    OC_EH_RESOURCE_DELETED = 202,
    OC_EH_VALID = 203,
    OC_EH_CHANGED = 204,
    OC_EH_CONTENT = 205,
    OC_EH_BAD_REQ = 400,
    OC_EH_UNAUTHORIZED_REQ = 401,
    OC_EH_BAD_OPT = 402,
    OC_EH_FORBIDDEN = 403,
    OC_EH_RESOURCE_NOT_FOUND = 404,
    OC_EH_METHOD_NOT_ALLOWED = 405,
    OC_EH_NOT_ACCEPTABLE = 406,
    OC_EH_TOO_LARGE = 413,
    OC_EH_UNSUPPORTED_MEDIA_TYPE = 415,
    OC_EH_INTERNAL_SERVER_ERROR = 500,
    OC_EH_BAD_GATEWAY = 502,
    OC_EH_SERVICE_UNAVAILABLE = 503,
    OC_EH_RETRANSMIT_TIMEOUT = 504
}OCEntityHandlerResult;
typedef enum {
    /** Request state.*/
    OC_REQUEST_FLAG = (1 << 1),
    /** Observe state.*/
    OC_OBSERVE_FLAG = (1 << 2)
}OCEntityHandlerFlag;
typedef void *OCResourceHandle;
typedef void *OCRequestHandle;
typedef enum {
    /** To Register. */
    OC_OBSERVE_REGISTER = 0,

    /** To Deregister. */
    OC_OBSERVE_DEREGISTER = 1,

    /** Others. */
    OC_OBSERVE_NO_OPTION = 2,

}OCObserveAction;
typedef uint8_t OCObservationId;
typedef struct {
    /** Action associated with observation request.*/
    OCObserveAction action;

    /** Identifier for observation being registered/deregistered.*/
    OCObservationId obsId;
}OCObservationInfo;
typedef struct OCHeaderOption OCHeaderOption;
typedef enum {
    /** For invalid ID.*/
    OC_INVALID_ID   = (1 << 0),

    /* For coap ID.*/
    OC_COAP_ID      = (1 << 1)
}OCTransportProtocolID;
#define MAX_HEADER_OPTION_DATA_LENGTH (1024)
struct OCHeaderOption {
    /** The protocol ID this option applies to.*/
    OCTransportProtocolID protocolID;

    /** The header option ID which will be added to communication packets.*/
    uint16_t optionID;

    /** its length 191.*/
    uint16_t optionLength;

    /** pointer to its data.*/
    uint8_t optionData[MAX_HEADER_OPTION_DATA_LENGTH];

/* #ifdef __cplusplus
 *     OCHeaderOption() = default;
 *     OCHeaderOption(OCTransportProtocolID pid,
 *                    uint16_t optId,
 *                    uint16_t optlen,
 *                    const uint8_t* optData)
 *         : protocolID(pid),
 *           optionID(optId),
 *           optionLength(optlen)
 *     {
 * 
 *         // parameter includes the null terminator.
 *         optionLength = optionLength < MAX_HEADER_OPTION_DATA_LENGTH ?
 *                         optionLength : MAX_HEADER_OPTION_DATA_LENGTH;
 *         memcpy(optionData, optData, optionLength);
 *         optionData[optionLength - 1] = '\0';
 *     }
 * #endif // __cplusplus */
};
#include <stddef.h>
typedef enum {
    /** Contents of the payload are invalid */
    PAYLOAD_TYPE_INVALID,
    /** The payload is an OCDiscoveryPayload */
    PAYLOAD_TYPE_DISCOVERY,
    /** The payload of the device */
    PAYLOAD_TYPE_DEVICE,
    /** The payload type of the platform */
    PAYLOAD_TYPE_PLATFORM,
    /** The payload is an OCRepPayload */
    PAYLOAD_TYPE_REPRESENTATION,
    /** The payload is an OCSecurityPayload */
    PAYLOAD_TYPE_SECURITY,
    /** The payload is an OCPresencePayload */
    PAYLOAD_TYPE_PRESENCE,
    /** The payload is an OCDiagnosticPayload */
    PAYLOAD_TYPE_DIAGNOSTIC,
    /** The payload is an OCIntrospectionPayload */
    PAYLOAD_TYPE_INTROSPECTION
}OCPayloadType;
typedef struct {
    /** The type of message that was received */
    OCPayloadType type;
}OCPayload;
typedef struct {
    /** Associated resource.*/
    OCResourceHandle resource;

    /** Associated request handle.*/
    OCRequestHandle requestHandle;

    /** the REST method retrieved from received request PDU.*/
    OCMethod method;

    /** description of endpoint that sent the request.*/
    OCDevAddr devAddr;

    /** resource query send by client.*/
    char * query;

    /** Information associated with observation - valid only when OCEntityHandler flag includes
     * ::OC_OBSERVE_FLAG.*/
    OCObservationInfo obsInfo;

    /** Number of the received vendor specific header options.*/
    uint8_t numRcvdVendorSpecificHeaderOptions;

    /** Pointer to the array of the received vendor specific header options.*/
    OCHeaderOption * rcvdVendorSpecificHeaderOptions;

    /** Message id.*/
    uint16_t messageID;

    /** the payload from the request PDU.*/
    OCPayload *payload;

}OCEntityHandlerRequest;
typedef OCEntityHandlerResult(*OCEntityHandler)(OCEntityHandlerFlag flag,OCEntityHandlerRequest *entityHandlerRequest,void *callbackParam);
typedef OCEntityHandlerResult(*OCDeviceEntityHandler)(OCEntityHandlerFlag flag,OCEntityHandlerRequest *entityHandlerRequest,char *uri,void *callbackParam);
#if defined(TCP_ADAPTER)
typedef void(*CAKeepAliveConnectionCallback)(const CAEndpoint_t *object,bool isConnected,bool isClient);
void CARegisterKeepAliveHandler(CAKeepAliveConnectionCallback ConnHandler);
void CARegisterKeepAliveHandler(CAKeepAliveConnectionCallback ConnHandler);
#endif
typedef void(*CAThreadTask)(void *threadData);
typedef void(*CADataDestroyFunction)(void *data,uint32_t size);
typedef struct ca_thread_pool ca_thread_pool;
typedef struct ca_thread_pool *ca_thread_pool_t;
#define HAVE_TIME_H 1
#if defined(HAVE_TIME_H)
#include <time.h>
#endif
#define HAVE_SYS_TIME_H 1
#if defined(HAVE_SYS_TIME_H)
#include <sys/time.h>
#endif
typedef struct oc_mutex_internal *oc_mutex;
typedef struct oc_cond_internal *oc_cond;
typedef struct u_queue_t u_queue_t;
typedef struct u_queue_element u_queue_element;
struct u_queue_t {
    /** Head of the queue. */
    u_queue_element *element;
    /** Number of messages in Queue. */
    uint32_t count;
};
typedef struct {
    /** Thread pool of the thread started. **/
    ca_thread_pool_t threadPool;
    /** mutex for synchronization. **/
    oc_mutex threadMutex;
    /** conditional mutex for synchronization. **/
    oc_cond threadCond;
    /** Thread function to be invoked. **/
    CAThreadTask threadTask;
    /** Data destroy function. **/
    CADataDestroyFunction destroy;
    /** Variable to inform the thread to stop. **/
    bool isStop;
    /** Que on which the thread is operating. **/
    u_queue_t *dataQueue;
}CAQueueingThread_t;
#if defined(RA_ADAPTER)
typedef void(*jid_bound_cb)(char *jid);
typedef struct {
    char *hostname;     /**< XMPP server hostname */
    uint16_t   port;    /**< XMPP server serivce port */
    char *xmpp_domain;  /**< XMPP login domain */
    char *username;     /**< login username */
    char *password;     /**< login password */
    char *resource;     /**< specific resource for login */
    char *user_jid;     /**< specific JID for login */
    jid_bound_cb jidbound;  /**< callback when JID bound */
}OCRAInfo_t;
#endif
typedef void(*ca_thread_func)(void *);
struct ca_thread_pool {
    struct ca_thread_pool_details_t* details;
};
#include <unistd.h>
typedef struct ByteArray ByteArray;
struct ByteArray {
    uint8_t *data;    /**< Pointer to the byte array */
    size_t len;      /**< Data size */
};
typedef struct ByteArray ByteArray_t;
typedef ByteArray_t SslCacheMessage_t;
#if !defined(SINGLE_THREAD)
typedef struct {
    CAEndpoint_t *remoteEndpoint;
    void *data;
    uint32_t dataLen;
    bool isMulticast;
}CAIPData_t;
#endif
#define INTERFACE_NAME_MAX 16
typedef void(*CAIPAdapterStateChangeCallback)(CATransportAdapter_t adapter,CANetworkStatus_t status);
typedef struct {
    char name[INTERFACE_NAME_MAX];
    uint32_t index;
    uint32_t flags;
    uint16_t family;
    char addr[MAX_ADDR_STR_SIZE_CA];
}CAInterface_t;
typedef struct CAIPCBData_t CAIPCBData_t;
struct CAIPCBData_t {
    struct CAIPCBData_t *next;
    CATransportAdapter_t adapter;
    CAIPAdapterStateChangeCallback callback;
};
#define CA_SECURE_ENDPOINT_PUBLIC_KEY_MAX_LENGTH    (512)
typedef struct {
    CAEndpoint_t endpoint;      /**< endpoint */
    // TODO change name to deviceId
    CARemoteId_t identity;      /**< endpoint device uuid */
    CARemoteId_t userId;        /**< endpoint user uuid */
    uint32_t attributes;
    uint8_t publicKey[CA_SECURE_ENDPOINT_PUBLIC_KEY_MAX_LENGTH]; /**< Peer's DER-encoded public key (if using certificate) */
    size_t publicKeyLength;     /**< Length of publicKey; zero if not using certificate */
}CASecureEndpoint_t;
typedef void(*CAIPPacketReceivedCallback)(const CASecureEndpoint_t *sep,const void *data,size_t dataLength);
typedef void(*CAIPErrorHandleCallback)(const CAEndpoint_t *endpoint,const void *data,size_t dataLength,CAResult_t result);
#define CA_COAP        5683
#define CA_SECURE_COAP 5684
#define OC_MULTICAST_DISCOVERY_URI            "/oic/res"
#define OC_SPEC_VERSION_VALUE            2048
#define OCF_VERSION_1_0_0 OC_SPEC_VERSION_VALUE
#define OCF_VERSION_1_1_0                2112
#define MAX_QUERY_LENGTH (256)
#include <inttypes.h>
typedef enum {
    CA_LOG_LEVEL_ALL = 1,             // all logs.
    CA_LOG_LEVEL_INFO,                // debug level is disabled.
}CAUtilLogLevel_t;
#define PCF(str) str
typedef enum {
    OC_LOG_MIN_VAL__   = -1,
    OC_LOG_ALL         = 0,
    OC_LOG_FATAL,
    OC_LOG_ERROR,
    OC_LOG_WARNING,
    OC_LOG_INFO,
    OC_LOG_DEBUG,
    OC_LOG_DISABLED,
    OC_LOG_MAX_VAL__
}oc_log_level;
typedef struct _oc_log_ctx _oc_log_ctx;
struct _oc_log_ctx {
    void*                  ctx;

    oc_log_level           log_level;

    char*                  module_name;

    /* Required interface: */
    int  (*init)           (struct _oc_log_ctx *, void *);
    void (*destroy)        (struct _oc_log_ctx *);
    void (*flush)          (struct _oc_log_ctx *);
    void (*set_level)      (struct _oc_log_ctx *, const int);
    size_t (*write_level)  (struct _oc_log_ctx *, const int, const char *);
    int  (*set_module)     (struct _oc_log_ctx *, const char *);

    /* Optional interface (if one is implemented, all must be implemented): */
    int (*lock)            (struct _oc_log_ctx *);
    int (*unlock)          (struct _oc_log_ctx *);
    int (*try_lock)        (struct _oc_log_ctx *);
    int (*locked_destroy)  (struct _oc_log_ctx *);
};
typedef struct _oc_log_ctx oc_log_ctx_t;
typedef int(*oc_log_init_t)(oc_log_ctx_t *,void *);
typedef void(*oc_log_destroy_t)(oc_log_ctx_t *);
typedef void(*oc_log_flush_t)(oc_log_ctx_t *);
typedef void(*oc_log_set_level_t)(oc_log_ctx_t *,const int);
typedef size_t(*oc_log_write_level_t)(oc_log_ctx_t *,const int,const char *);
typedef int(*oc_log_set_module_t)(oc_log_ctx_t *,const char *);
typedef int(*oc_log_lock_t)(oc_log_ctx_t *);
typedef int(*oc_log_unlock_t)(oc_log_ctx_t *);
typedef int(*oc_log_try_lock_t)(oc_log_ctx_t *);
typedef int(*log_writer_t)(const char *format,...);
void oocf_log_hook_stdout(log_writer_t hook);
void oocf_log_hook_stdout(log_writer_t hook);
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define MAX_LOG_V_BUFFER_SIZE (256)
#define OC_LOG_PRIVATE_DATA (1 << 31)
#define DEBUG 0
#define DEBUG_PRIVATE       ((OC_LOG_PRIVATE_DATA) | (DEBUG))
#define INFO 1
#define INFO_PRIVATE        ((OC_LOG_PRIVATE_DATA) | (INFO))
#define WARNING 2
#define WARNING_PRIVATE     ((OC_LOG_PRIVATE_DATA) | (WARNING))
#define ERROR 3
#define ERROR_PRIVATE       ((OC_LOG_PRIVATE_DATA) | (ERROR))
#define FATAL 4
#define FATAL_PRIVATE       ((OC_LOG_PRIVATE_DATA) | (FATAL))
#if !defined(OC_LOG_LEVEL)
#define OC_MINIMUM_LOG_LEVEL    (DEBUG)
#endif
#if !(!defined(OC_LOG_LEVEL))
#define OC_MINIMUM_LOG_LEVEL    (OC_LOG_LEVEL)
#endif
enum LogLevel {
    LL_DEBUG = 0,
    LL_INFO,
    LL_WARNING,
    LL_ERROR,
    LL_FATAL,
    LL_DEBUG_LITE,       // The DEBUG log for Lite device
    LL_INFO_LITE,        // The INFO log for Lite device
};
typedef enum LogLevel LogLevel;
#define DEBUG_LITE 5
#define INFO_LITE 6
void OCLogBuffer(int level,const char *tag,int line_number,const uint8_t *buffer,size_t bufferSize);
#define TB_LOG /**/
#if defined(TB_LOG)
#define OIC_LOG_BUFFER(level, tag, buffer, bufferSize) \
    do { \
    if (((int)OC_MINIMUM_LOG_LEVEL) <= ((int)(level & (~OC_LOG_PRIVATE_DATA)))) \
            OCLogBuffer((level), __FILE__, __LINE__, (buffer), (bufferSize)); \
    } while(0)
#endif
#if !(defined(TB_LOG))
#define OIC_LOG_BUFFER(level, tag, buffer, bufferSize)
#endif
#if defined(TB_LOG)
#define OIC_LOG_CA_BUFFER(level, tag, buffer, bufferSize, isHeader) \
    do { \
    if (((int)OC_MINIMUM_LOG_LEVEL) <= ((int)(level & (~OC_LOG_PRIVATE_DATA)))) \
            OCPrintCALogBuffer((level), __FILE__, __LINE__, (buffer), (bufferSize), (isHeader)); \
    } while(0)
#endif
#if !(defined(TB_LOG))
#define OIC_LOG_CA_BUFFER(level, tag, buffer, bufferSize, isHeader)
#endif
void OCLogConfig(oc_log_ctx_t *ctx);
#if defined(TB_LOG)
#define OIC_LOG_CONFIG(ctx)    OCLogConfig((ctx))
#endif
#if !(defined(TB_LOG))
#define OIC_LOG_CONFIG(ctx)
#endif
void OCLogShutdown();
#if defined(TB_LOG)
#define OIC_LOG_SHUTDOWN()     OCLogShutdown()
#endif
#if !(defined(TB_LOG))
#define OIC_LOG_SHUTDOWN()
#endif
void OCLog(int level,const char *tag,const char *logStr);
#if defined(TB_LOG)
#define OIC_LOG(level, tag, logStr) \
    do { \
    if (((int)OC_MINIMUM_LOG_LEVEL) <= ((int)(level & (~OC_LOG_PRIVATE_DATA)))) \
	    OCLog((level), (__FILE__ ":" TOSTRING(__LINE__)), (logStr));	\
    } while(0)
#endif
#if !(defined(TB_LOG))
#define OIC_LOG(level, tag, logStr)
#endif
void OCLogv(int level,const char *tag,int line_nbr,const char *format,...);
#if defined(TB_LOG)
#define OIC_LOG_V(level, tag, ...) \
    do { \
    if (((int)OC_MINIMUM_LOG_LEVEL) <= ((int)(level & (~OC_LOG_PRIVATE_DATA)))) \
	    OCLogv((level), __FILE__, __LINE__, __VA_ARGS__); \
    } while(0)
#endif
#if !(defined(TB_LOG))
#define OIC_LOG_V(level, tag, ...)
#define OIC_LOG_INIT()
#endif
typedef void *OCDoHandle;
typedef struct {
    /** Identity Length */
    uint16_t id_length;

    /** Array of end point identity.*/
    unsigned char id[MAX_IDENTITY_SIZE];
}OCIdentity;
typedef enum {
    /** Success status code - START HERE.*/
    OC_STACK_OK = 0,                /** 203, 205*/
    OC_STACK_RESOURCE_CREATED,      /** 201*/
    OC_STACK_RESOURCE_DELETED,      /** 202*/
    OC_STACK_CONTINUE,
    OC_STACK_RESOURCE_CHANGED,      /** 204*/
    /** Success status code - END HERE.*/

    /** Error status code - START HERE.*/
    OC_STACK_INVALID_URI = 20,
    OC_STACK_INVALID_QUERY,         /** 400*/
    OC_STACK_INVALID_IP,
    OC_STACK_INVALID_PORT,
    OC_STACK_INVALID_CALLBACK,
    OC_STACK_INVALID_METHOD,

    /** Invalid parameter.*/
    OC_STACK_INVALID_PARAM,
    OC_STACK_INVALID_OBSERVE_PARAM,
    OC_STACK_NO_MEMORY,
    OC_STACK_COMM_ERROR,            /** 504*/
    /* FIXME: support CAResult_t codes */
    OC_STACK_CA_SERVER_STARTED_ALREADY,
    OC_STACK_CA_SERVER_NOT_STARTED,
    /* CA_DESTINATION_NOT_REACHABLE,   /\**< Destination is not reachable *\/
     * CA_SOCKET_OPERATION_FAILED,     /\**< Socket operation failed *\/
     * CA_SEND_FAILED,                 /\**< Send request failed *\/
     * CA_RECEIVE_FAILED,              /\**< Receive failed *\/
     * CA_DESTINATION_DISCONNECTED,    /\**< Destination is disconnected *\/
     * CA_STATUS_NOT_INITIALIZED,      /\**< Not Initialized*\/
     * CA_DTLS_AUTHENTICATION_FAILURE, /\**< Decryption error in DTLS *\/
     * CA_HANDLE_ERROR_OTHER_MODULE,   /\**< Error happens but it should be handled in other module *\/ */
    OC_STACK_TIMEOUT,
    OC_STACK_ADAPTER_NOT_ENABLED,
    OC_STACK_NOTIMPL,

    /** Resource not found.*/
    OC_STACK_NO_RESOURCE,           /** 404*/

    /** e.g: not supported method or interface.*/
    OC_STACK_RESOURCE_ERROR,
    OC_STACK_SLOW_RESOURCE,
    OC_STACK_DUPLICATE_REQUEST,

    /** Resource has no registered observers.*/
    OC_STACK_NO_OBSERVERS,
    OC_STACK_OBSERVER_NOT_FOUND,
    OC_STACK_VIRTUAL_DO_NOT_HANDLE,
    OC_STACK_INVALID_OPTION,        /** 402*/

    /** The remote reply contained malformed data.*/
    OC_STACK_MALFORMED_RESPONSE,
    OC_STACK_PERSISTENT_BUFFER_REQUIRED,
    OC_STACK_INVALID_REQUEST_HANDLE,
    OC_STACK_INVALID_DEVICE_INFO,
    OC_STACK_INVALID_JSON,

    /** Request is not authorized by Resource Server. */
    OC_STACK_UNAUTHORIZED_REQ,      /** 401*/
    OC_STACK_TOO_LARGE_REQ,         /** 413*/

    /** Error code from PDM */
    OC_STACK_PDM_IS_NOT_INITIALIZED,
    OC_STACK_DUPLICATE_UUID,
    OC_STACK_INCONSISTENT_DB,

    /**
     * Error code from OTM
     * This error is pushed from DTLS interface when handshake failure happens
     */
    OC_STACK_AUTHENTICATION_FAILURE,
    OC_STACK_NOT_ALLOWED_OXM,
    OC_STACK_CONTINUE_OPERATION,

    /** Request come from endpoint which is not mapped to the resource. */
    OC_STACK_BAD_ENDPOINT,

    /** Insert all new error codes here!.*/
#ifdef WITH_PRESENCE
    OC_STACK_PRESENCE_STOPPED = 128,
    OC_STACK_PRESENCE_TIMEOUT,
    OC_STACK_PRESENCE_DO_NOT_HANDLE,
#endif

    /** Request is denied by the user*/
    OC_STACK_USER_DENIED_REQ,
    OC_STACK_NOT_ACCEPTABLE,

    /** ERROR code from server */
    OC_STACK_FORBIDDEN_REQ,          /** 403*/
    OC_STACK_INTERNAL_SERVER_ERROR,  /** 500*/
    OC_STACK_GATEWAY_TIMEOUT,        /** 504*/
    OC_STACK_SERVICE_UNAVAILABLE,    /** 503*/

    /** ERROR in stack.*/
    OC_STACK_ERROR = 255
    /** Error status code - END HERE.*/
}OCStackResult;
#define MAX_HEADER_OPTIONS (50)
typedef struct {
    /** Address of remote server.*/
    OCDevAddr devAddr;

    /** backward compatibility (points to devAddr).*/
    OCDevAddr *addr;

    /** backward compatibility.*/
    OCConnectivityType connType;

    /** the security identity of the remote server.*/
    OCIdentity identity;	/* GAR: not used for discovery responses? */

    /** the is the result of our stack, OCStackResult should contain coap/other error codes.*/
    OCStackResult result;

    /** If associated with observe, this will represent the sequence of notifications from server.*/
    uint32_t sequenceNumber;

    /** resourceURI.*/
    const char * resourceUri;

    /** the payload for the response PDU.*/
    OCPayload *payload;

    /** Number of the received vendor specific header options.*/
    uint8_t numRcvdVendorSpecificHeaderOptions;

    /** An array of the received vendor specific header options.*/
    OCHeaderOption rcvdVendorSpecificHeaderOptions[MAX_HEADER_OPTIONS];
}OCClientResponse;
typedef OCStackApplicationResult(*OCClientResponseHandler)(void *context,OCDoHandle handle,OCClientResponse *clientResponse);
typedef void(*OCClientContextDeleter)(void *context);
typedef struct OCCallbackData OCCallbackData;
struct OCCallbackData {
    /** Pointer to the context.*/
    void *context;

    /** The pointer to a function the stack will call to handle the requests.*/
    OCClientResponseHandler cb;

    /** A pointer to a function to delete the context when this callback is removed.*/
    OCClientContextDeleter cd;

#ifdef __cplusplus
    OCCallbackData() = default;
    OCCallbackData(void* ctx, OCClientResponseHandler callback, OCClientContextDeleter deleter)
        :context(ctx), cb(callback), cd(deleter){}
#endif // __cplusplus
};
typedef enum {
    OCREP_PROP_NULL,
    OCREP_PROP_INT,
    OCREP_PROP_DOUBLE,
    OCREP_PROP_BOOL,
    OCREP_PROP_STRING,
    OCREP_PROP_BYTE_STRING,
    OCREP_PROP_OBJECT,
    OCREP_PROP_ARRAY
}OCRepPayloadPropType;
typedef struct {
    /** pointer to data bytes.*/
    uint8_t* bytes;

    /** number of data bytes.*/
    size_t   len;
}OCByteString;
#define MAX_REP_ARRAY_DEPTH 3
typedef struct OCRepPayload OCRepPayload;
typedef struct OCStringLL OCStringLL;
struct OCStringLL {
    struct OCStringLL *next;
    char* value;
};
typedef struct OCRepPayloadValue OCRepPayloadValue;
struct OCRepPayload {
    OCPayload base;
    char* uri;
    OCStringLL* types;
    OCStringLL* interfaces;
    OCRepPayloadValue* values;
    struct OCRepPayload* next;
};
typedef struct OCEndpointPayload OCEndpointPayload;
struct OCEndpointPayload {
    char* tps;
    char* addr;
    OCTransportFlags family;
    uint16_t port;
    uint16_t pri;
    struct OCEndpointPayload* next;
};
typedef struct OCResourcePayload OCResourcePayload;
struct OCResourcePayload {
    char* uri;			/* property "href" (mandatory) */
    char* rel;
    char* anchor; /* NB: for OIC 1.1, a transfer URI; for OCF 1.0, a OCF URI */
    OCStringLL* types;		/* property "rt" (mandatory) */
    OCStringLL* interfaces;	/* property "if" (mandatory) */
    uint8_t bitmap;		/* visibility policy bitmask: discoverable, observable */
    /* OCF 1.0: "sec" and "port" ... used only in a response payload
       when the request does not include an
       OCF-Accept-Content-Format-Version option, i.e. OIC 1.1
       clients. OCF 1.0 uses eps to convey info about encrypted
       endpoints */
    bool secure;
    uint16_t port;
#ifdef TCP_ADAPTER
    uint16_t tcpPort;
#endif
    struct OCResourcePayload* next;
    OCEndpointPayload* eps;  /* OCF 1.0 */
    /* GAR: what about the remaining optional parameters, e.g. di, type (mt?), etc. */
};
typedef struct OCDiscoveryPayload OCDiscoveryPayload;
struct OCDiscoveryPayload {
    OCPayload base;

    /** Device Id */
    char *sid;			/* property "di" (OIC 1.1 only mandatory) */

    /** Name */
    char *name;			/* propery "n" (optional) */

    /** Resource Type */
    OCStringLL *type;		/* propery "rt" (mandatory) */

    /** Interface */
    OCStringLL *iface;		/* property "if" (mandatory) */

    /** This structure holds the old /oic/res response. */
    OCResourcePayload *resources; /* property "links" (mandatory) */

    /** Holding address of the next DiscoveryPayload. */
    struct OCDiscoveryPayload *next;

    /* GAR: property "mpro" (messaging protocol support)? */

};
typedef struct {
    OCPayload base;
    uint8_t* securityData;
    size_t payloadSize;
}OCSecurityPayload;
typedef struct {
    OCPayload base;
    char* message;
}OCDiagnosticPayload;
typedef struct {
    OCPayload base;
    OCByteString cborPayload;
}OCIntrospectionPayload;
#define OC_OBSERVER_NOT_INTERESTED       (0)
#define OC_OBSERVER_STILL_INTERESTED     (1)
#define OC_OBSERVER_FAILED_COMM          (2)
#define OC_RSRVD_INTROSPECTION_URI_PATH            "/introspection"
#define OC_RSRVD_INTROSPECTION_PAYLOAD_URI_PATH    "/introspection/payload"
typedef struct occapability occapability;
struct occapability {
    /** Linked list; for multiple capabilities.*/
    struct occapability* next;

    /** It is a name about resource capability. */
    char *capability;

    /** It is mean status of capability. */
    char *status;
};
typedef struct occapability OCCapability;
typedef struct ocaction ocaction;
struct ocaction {
    /** linked list; for multiple actions. */
    struct ocaction *next;

    /** Target Uri. It will be used to execute the action. */
    char *resourceUri;

    /** head pointer of a linked list of capability nodes.*/
    OCCapability* head;
};
typedef struct ocaction OCAction;
typedef struct ocactionset ocactionset;
struct ocactionset {
    /** linked list; for list of action set. */
    struct ocactionset *next;

    /** Name of the action set.*/
    char *actionsetName;

    /** Time stamp.*/
    long int timesteps;

    /** Type of action.*/
    unsigned int type;

    /** head pointer of a linked list of Actions.*/
    OCAction* head;
};
typedef struct ocactionset OCActionSet;
typedef struct resourcetype_t resourcetype_t;
struct resourcetype_t {

    /** linked list; for multiple types on resource. */
    struct resourcetype_t *next;

    /**
     * Name of the type; this string is ‘.’ (dot) separate list of segments where each segment is a
     * namespace and the final segment is the type; type and sub-types can be separate with
     * ‘-‘ (dash) usually only two segments would be defined. Either way this string is meant to be
     * human friendly and is used opaquely and not parsed by code. This name is used in the “rt=”
     * parameter of a resource description when resources are introspected and is also use in the
     * " <base URI>/types " list of available types.
    */
    char *resourcetypename;
};
typedef struct resourcetype_t OCResourceType;
typedef struct OCAttribute OCAttribute;
struct OCAttribute {

    /** Points to next resource in list.*/
    struct OCAttribute *next;

    /** The name of the attribute; used to look up the attribute in list.
     *  for a given attribute SHOULD not be changed once assigned.
     */
    char *attrName;

    /** value of the attribute as void. To support both string and ::OCStringLL value*/
    void *attrValue;
};
typedef struct resourceinterface_t resourceinterface_t;
struct resourceinterface_t {

    /** linked list; for multiple interfaces on resource.*/
    struct resourceinterface_t *next;

    /** Name of the interface; this is ‘.’ (dot) separate list of segments where each segment is a
     * namespace and the final segment is the interface; usually only two segments would be
     * defined. Either way this string is opaque and not parsed by segment.*/
    char *name ;

    /** Supported content types to serialize request and response on this interface
     * (REMOVE for V1 – only jSON for all but core.ll that uses Link Format)*/
#if 0
    char *inputContentType ;
    char *outputContentType ;
#endif
    /** Future placeholder for access control and policy.*/
};
typedef struct resourceinterface_t OCResourceInterface;
typedef struct OCChildResource OCChildResource;
typedef struct OCResource OCResource;
#define __WITH_DTLS__ /**/
typedef enum {
    /** When none of the bits are set, the resource is non-secure, non-discoverable &
     *  non-observable by the client.*/
    OC_RES_PROP_NONE = (0),

    /** When this bit is set, the resource is allowed to be discovered by clients.*/
    OC_DISCOVERABLE  = (1 << 0),

    /** When this bit is set, the resource is allowed to be observed by clients.*/
    OC_OBSERVABLE    = (1 << 1),

    /** When this bit is set, the resource is initialized, otherwise the resource
     *  is 'inactive'. 'inactive' signifies that the resource has been marked for
     *  deletion or is already deleted.*/
    OC_ACTIVE        = (1 << 2),

    /** When this bit is set, the resource has been marked as 'slow'.
     * 'slow' signifies that responses from this resource can expect delays in
     *  processing its requests from clients.*/
    OC_SLOW          = (1 << 3),

    /** When this bit is set, the resource supports access via non-secure endpoints. */
    OC_NONSECURE     = (1 << 6),

#if defined(__WITH_DTLS__) || defined(__WITH_TLS__)
    /** When this bit is set, the resource is a secure resource.*/
    OC_SECURE        = (1 << 4),
#else
    OC_SECURE        = (0),
#endif

    /** When this bit is set, the resource is allowed to be discovered only
     *  if discovery request contains an explicit querystring.
     *  Ex: GET /oic/res?rt=oic.sec.acl */
    OC_EXPLICIT_DISCOVERABLE   = (1 << 5)

#ifdef WITH_MQ
    /** When this bit is set, the resource is allowed to be published */
    // @todo
    // Since this property is not defined on OCF Spec. it should be set 0 until define it
    ,OC_MQ_PUBLISHER     = (0)
#endif

#ifdef MQ_BROKER
    /** When this bit is set, the resource is allowed to be notified as MQ broker.*/
    // @todo
    // Since this property is not defined on OCF Spec. it should be set 0 until define it
    ,OC_MQ_BROKER        = (0)
#endif
}OCResourceProperty;
typedef struct ResourceObserver ResourceObserver;
typedef enum {
    /** Packet delivery is best effort.*/
    OC_LOW_QOS = 0,

    /** Packet delivery is best effort.*/
    OC_MEDIUM_QOS,

    /** Acknowledgments are used to confirm delivery.*/
    OC_HIGH_QOS,

    /** No Quality is defined, let the stack decide.*/
    OC_NA_QOS
}OCQualityOfService;
typedef enum {
    OC_FORMAT_CBOR,
    OC_FORMAT_VND_OCF_CBOR,
    OC_FORMAT_JSON,
    OC_FORMAT_UNDEFINED,
    OC_FORMAT_UNSUPPORTED,
}OCPayloadFormat;
struct ResourceObserver {
    /** Observation Identifier for request.*/
    OCObservationId observeId;

    /** URI of observed resource.*/
    char *resUri;

    /** Query.*/
    char *query;

    /** token for the observe request.*/
    CAToken_t token;

    /** token length for the observe request.*/
    uint8_t tokenLength;

    /** Remote Endpoint. */
    OCDevAddr devAddr;

    /** Quality of service of the request.*/
    OCQualityOfService qos;

    /** number of times the server failed to reach the observer.*/
    uint8_t failedCommCount;

    /** number of times the server sent NON notifications.*/
    uint8_t lowQosCount;

    /** force the qos value to CON.*/
    uint8_t forceHighQos;

    /** The TTL for this callback. TTL is set to 24 hours.
     * A server send a notification in a confirmable message every 24 hours.
     * This prevents a client that went away or is no logger interested
     * from remaining in the list of observers indefinitely.*/
    uint32_t TTL;

    /** next node in this list.*/
    struct ResourceObserver *next;

    /** requested payload encoding format. */
    OCPayloadFormat acceptFormat;

    /** requested payload content version. */
    uint16_t acceptVersion;

};
typedef enum {
    /** For initialize */
    OC_NO_TPS         = 0,

    /** coap + udp */
    OC_COAP           = 1,

    /** coaps + udp */
    OC_COAPS          = (1 << 1),

#ifdef TCP_ADAPTER
    /** coap + tcp */
    OC_COAP_TCP       = (1 << 2),

    /** coaps + tcp */
    OC_COAPS_TCP      = (1 << 3),
#endif
#ifdef HTTP_ADAPTER
    /** http + tcp */
    OC_HTTP           = (1 << 4),

    /** https + tcp */
    OC_HTTPS          = (1 << 5),
#endif
#ifdef EDR_ADAPTER
    /** coap + rfcomm */
    OC_COAP_RFCOMM    = (1 << 6),
#endif
#ifdef LE_ADAPTER
    /** coap + gatt */
    OC_COAP_GATT      = (1 << 7),
#endif
#ifdef NFC_ADAPTER
    /** coap + nfc */
    OC_COAP_NFC       = (1 << 8),
#endif
#ifdef RA_ADAPTER
    /** coap + remote_access */
    OC_COAP_RA        = (1 << 9),
#endif
    /** Allow all endpoint.*/
    OC_ALL       = 0xffff
}OCTpsSchemeFlags;
struct OCResource {

    /** Points to next resource in list.*/
    struct OCResource *next;

    /** Relative path on the device; will be combined with base url to create fully qualified path.*/
    char *uri;

    /** Resource type(s); linked list.*/
    OCResourceType *rsrcType;

    /** Resource interface(s); linked list.*/
    OCResourceInterface *rsrcInterface;

    /** Resource attributes; linked list.*/
    OCAttribute *rsrcAttributes;

    /** Array of pointers to resources; can be used to represent a container of resources.
     * (i.e. hierarchies of resources) or for reference resources (i.e. for a resource collection).*/

    /** Child resource(s); linked list.*/
    OCChildResource *rsrcChildResourcesHead;

    /** Pointer to function that handles the entity bound to the resource.
     *  This handler has to be explicitly defined by the programmer.*/
    OCEntityHandler entityHandler;

    /** Callback parameter.*/
    void * entityHandlerCallbackParam;

    /** Properties on the resource – defines meta information on the resource.
     * (ACTIVE, DISCOVERABLE etc ). */

    OCResourceProperty resourceProperties ;

    /* @note: Methods supported by this resource should be based on the interface targeted
     * i.e. look into the interface structure based on the query request Can be removed here;
     * place holder for the note above.*/
    /* method_t methods; */

    /** Observer(s); linked list.*/
    ResourceObserver *observersHead;

    /** Sequence number for observable resources. Per the CoAP standard it is a 24 bit value.*/
    uint32_t sequenceNum;

    /** Pointer of ActionSet which to support group action.*/
    OCActionSet *actionsetHead;

    /** The instance identifier for this web link in an array of web links - used in links. */
    union
    {
        /** An ordinal number that is not repeated - must be unique in the collection context. */
        int64_t ins;
        /** Any unique string including a URI. */
        char *uniqueStr;
        /** Use UUID for universal uniqueness - used in /oic/res to identify the device. */
        OCIdentity uniqueUUID;
    };

    /** Resource endpoint type(s). */
    OCTpsSchemeFlags endpointType;
};
struct OCChildResource {
    struct OCResource *rsrcResource;
    struct OCChildResource *next;
};
#define MAX_URI_LENGTH (256)
typedef struct {
    /** Request handle.*/
    OCRequestHandle requestHandle;

    /** Resource handle. (@deprecated: This parameter is not used.) */
    OCResourceHandle resourceHandle;

    /** Allow the entity handler to pass a result with the response.*/
    OCEntityHandlerResult  ehResult;

    /** This is the pointer to server payload data to be transferred.*/
    OCPayload* payload;

    /** number of the vendor specific header options .*/
    uint8_t numSendVendorSpecificHeaderOptions;

    /** An array of the vendor specific header options the entity handler wishes to use in response.*/
    OCHeaderOption sendVendorSpecificHeaderOptions[MAX_HEADER_OPTIONS];

    /** Resource path of new resource that entity handler might create.*/
    char resourceUri[MAX_URI_LENGTH];

    /** Server sets to true for persistent response buffer,false for non-persistent response buffer*/
    uint8_t persistentBufferFlag;
}OCEntityHandlerResponse;
typedef enum {
    STACK_RES_DISCOVERY_NOFILTER = 0,
    STACK_RES_DISCOVERY_IF_FILTER,
    STACK_RES_DISCOVERY_RT_FILTER,
    STACK_DEVICE_DISCOVERY_DI_FILTER,
    STACK_DEVICE_DISCOVERY_DN_FILTER
}StackQueryTypes;
#if defined(_WIN32 			/* i.e. target is windows, any compiler */)
#  define OC_CALL   __stdcall
#endif
#if !(defined(_WIN32 			/* i.e. target is windows, any compiler */))
#  define OC_CALL
#endif
OCStackResult OC_CALL OCInit(const char *ipAddr,uint16_t port,OCMode mode);
OCStackResult OC_CALL OCStop();
OCStackResult OC_CALL OCDoResource(OCDoHandle *handle,OCMethod method,const char *requestUri,const OCDevAddr *destination,OCPayload *payload,OCConnectivityType connectivityType,OCQualityOfService qos,OCCallbackData *cbData,OCHeaderOption *options,uint8_t numOptions);
OCStackResult OC_CALL OCProcess(void);
OCStackResult OC_CALL OCCreateResource(OCResourceHandle *handle,const char *resourceTypeName,const char *resourceInterfaceName,const char *uri,OCEntityHandler entityHandler,void *callbackParam,uint8_t resourceProperties);
OCStackResult OC_CALL OCGetHeaderOption(OCHeaderOption *ocHdrOpt,size_t numOptions,uint16_t optionID,void *optionData,size_t optionDataLength,uint16_t *receivedDataLength);
typedef struct {
    /** Pointer to the device name.*/
    char *deviceName;
    /** Pointer to the types.*/
    OCStringLL *types;
    /** Pointer to the device specification version.*/
    char *specVersion;
    /** Pointer to the device data model versions (in CSV format).*/
    OCStringLL *dataModelVersions;
}OCDeviceInfo;
#if defined(TB_LOG)
#define UUID_SIZE (16)
#endif
#define UUID_STRING_SIZE (37)
#define HAVE_LIBPTHREAD 1
#if defined(HAVE_LIBPTHREAD)
#include <pthread.h>
#endif
typedef void(*TimerCallback)(void *ctx);
typedef enum {
    /** Success status code.*/
    OIC_PLATFORM_OK = 0,

    /** Error status code - START HERE.*/
    OIC_PLATFORM_INVALID_PARAM,	/* errno: EINVAL */
    OIC_PLATFORM_NO_MEMORY,	/* errno: ENOMEM */
    OIC_PLATFORM_NOTIMPL,	/* errno: ENOSYS */

    /** Generic ERROR.*/
    OIC_PLATFORM_ERROR = 255	/* GAR disallow? */
    /** Error status code - END HERE.*/
}OICPlatformResult_t;
#define OIC_UUID_LENGTH     16
#define OC_INVALID_THREAD_ID    0
typedef enum {
    OC_THREAD_SUCCESS = 0,
    OC_THREAD_ALLOCATION_FAILURE = 1,
    OC_THREAD_CREATE_FAILURE=2,
    OC_THREAD_INVALID=3,
    OC_THREAD_WAIT_FAILURE=4,
    OC_THREAD_INVALID_PARAMETER=5
}OCThreadResult_t;
typedef struct oc_thread_internal *oc_thread;
#include <stdlib.h>
enum OicSecOxm_t {
    OIC_JUST_WORKS                          = 0x0, /* oic.sec.doxm.jw */
    OIC_RANDOM_DEVICE_PIN                   = 0x1,
    OIC_MANUFACTURER_CERTIFICATE            = 0x2,
    OIC_DECENTRALIZED_PUBLIC_KEY            = 0x3,
    OIC_OXM_COUNT,
#ifdef MULTIPLE_OWNER
    OIC_PRECONFIG_PIN                       = 0xFF00,
#endif //MULTIPLE_OWNER
    OIC_MV_JUST_WORKS                       = 0xFF01,
    OIC_CON_MFG_CERT                        = 0xFF02,
};
typedef enum OicSecOxm_t OicSecOxm_t;
enum DoxmProperty_t {
    DOXM_OXMS = 1,
    DOXM_OXMSEL,
    DOXM_SCT,
    DOXM_OWNED,
#ifdef MULTIPLE_OWNER
    DOXM_SUBOWNER,
    DOXM_MOM,
#endif // MULTIPLE_OWNER
    DOXM_DEVICEUUID,
    DOXM_DEVOWNERUUID,
    DOXM_ROWNERUUID,
    DOXM_PROPERTY_COUNT
};
typedef enum DoxmProperty_t DoxmProperty_t;
typedef struct OicSecDoxm OicSecDoxm;
#include "cbor.h"
typedef enum {
    NO_SECURITY_MODE                = 0x0,
    SYMMETRIC_PAIR_WISE_KEY         = (0x1 << 0),
    SYMMETRIC_GROUP_KEY             = (0x1 << 1),
    ASYMMETRIC_KEY                  = (0x1 << 2),
    SIGNED_ASYMMETRIC_KEY           = (0x1 << 3),
    PIN_PASSWORD                    = (0x1 << 4),
    ASYMMETRIC_ENCRYPTION_KEY       = (0x1 << 5),
}OicSecCredType_t;
typedef struct OicUuid OicUuid;
#define UUID_LENGTH (128/8)
struct OicUuid {
    // <Attribute ID>:<Read/Write>:<Multiple/Single>:<Mandatory?>:<Type>
    //TODO fill in unless this is defined elsewhere?
    uint8_t             id[UUID_LENGTH];
};
typedef struct OicUuid OicUuid_t;
struct OicSecDoxm {
    // <Attribute ID>:<Read/Write>:<Multiple/Single>:<Mandatory?>:<Type>
    OicSecOxm_t         *oxm;           // 1:R:M:N:UINT16
    size_t              oxmLen;         // the number of elts in Oxm
    OicSecOxm_t         oxmSel;         // 2:R/W:S:Y:UINT16
    OicSecCredType_t    sct;            // 3:R:S:Y:oic.sec.credtype
    bool                owned;          // 4:R:S:Y:Boolean
    OicUuid_t           deviceID;       // 6:R:S:Y:oic.uuid
    bool                dpc;            // 7:R:S:Y:Boolean
    OicUuid_t           owner;          // 8:R:S:Y:oic.uuid
#ifdef MULTIPLE_OWNER
    OicSecSubOwner_t* subOwners;        //9:R/W:M:N:oic.uuid
    OicSecMom_t *mom;                   //10:R/W:S:N:oic.sec.mom
#endif //MULTIPLE_OWNER
    OicUuid_t           rownerID;       // 11:R:S:Y:oic.uuid
};
typedef struct OicSecDoxm OicSecDoxm_t;
#include <stdio.h>
typedef struct {
    /** Persistent storage file path.*/
    FILE* (* open)(const char *path, const char *mode);

    /** Persistent storage read handler.*/
    size_t (* read)(void *ptr, size_t size, size_t nmemb, FILE *stream);

    /** Persistent storage write handler.*/
    size_t (* write)(const void *ptr, size_t size, size_t nmemb, FILE *stream);

    /** Persistent storage close handler.*/
    int (* close)(FILE *fp);

    /** Persistent storage unlink handler.*/
    int (* unlink)(const char *path);
}OCPersistentStorage;
#include "coap/uri.h"
typedef struct OicParseQueryIter OicParseQueryIter;
struct OicParseQueryIter {
    unsigned char * attrPos;    /**< stating location of attribute. */
    size_t attrLen;             /**< length of the attribute. */
    unsigned char * valPos;     /**< starting location of value. */
    size_t valLen;              /**< length of the value. */
    coap_parse_iterator_t pi;   /**< coap struct for tokenizing the query.*/
};
typedef struct OicParseQueryIter OicParseQueryIter_t;
typedef struct u_linklist_data_t u_linklist_data_t;
struct u_linklist_data_t {
    void *data;
    u_linklist_data_t *next;
};
typedef struct u_linklist_data_t u_linklist_iterator_t;
typedef struct u_linklist u_linklist;
struct u_linklist {
    u_linklist_data_t *list;
    int size;
};
typedef struct u_linklist u_linklist_t;
typedef struct u_arraylist_t u_arraylist_t;
struct u_arraylist_t {
    void **data;
    size_t length;
    size_t capacity;
};
