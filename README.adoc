= OpenOCF

OpenOCF a minimal implementation of the OCF protocol, derived from
https://github.com/iotivity/iotivity[Iotivity].

Differences:

* Minimal, 100% C11 - only the C code from Iotivity, none of the C++ stuff
* The build system is https://bazel.build/[Bazel] instead of Scons.
* The code has been converted (reorganized) to a
  c-without-include-headers style, using
  https://www.hwaci.com/sw/mkhdr/[makeheaders] from D.Richard Hipp of
  Sqlite fame.
* Refactoring and renaming.
** API is the same, but source layout and some filenames have been changed.
** Easy cross-compilation (current targets: Raspberry Pi 3B, WindRiver Linux on Intel IoT Gateway, ARM, Android NDK)
* Arduino code is removed.
* Java/Android support has been migrated to a separate repo, https://github.com/OpenOCF/iochibity-java[iochibity-java]
** No Android-specific code in OpenOCF (Work In Progress). Android support in Iotivity involves having the stack call into Android to create objects etc. This has been removed.

The source is in `src/` and `third_party/`.

WARNING:  The source tree has been reorganized substantially:

* csdk -> //src

* security -> //src/sec

* security/provisioning -> //src/provisioning

* src and include subdirs have been removed - source and header files
  go in same director (bazel treats header files as source; this makes
  good sense imho)

* most header files are generated at build time, using
  makeheaders. The exceptions are .h files whose names have a leading
  underscore, e.g. `src/ocf/_device.h`; such files are processed by
  makeheaders, but are not #included anywhere.

[NOTE]
====
Using makeheaders to support a header-free style of programming may be
unorthodox, but so far it has been a very positive experience. Each
source file includes exactly one header, generated by makeheaders, of
the same name. For example, `foo.c` will `#include
foo.h`. That's it. This means never having to worry about headers. You
can refactor and reorganize your code at will, and makeheaders will
always figure you what needs to go in the header of each source file.

See the https://www.hwaci.com/sw/mkhdr/makeheaders.html[original
documentation] for a description of the rationale and working of
makeheaders. There are a few tricky bits to be aware of. For example,
if a function signature uses a datatype declared elsewhere
(e.g. uint32_t, from stdint.h), then that header must be #included
before the (generated) prototype in the generated headers that
need it. To enable this, enclose the #include within "#if
INTERFACE ... #endif". It is also possible to trip up makeheaders by
going overboard with macros.
====

== Building

First configure, then build.

OpenOCF uses GNU autotools (autoconf, etc.) for configuration.  You
will also need to configure the third-party libs. (Just coap so far). The
instructions are at the top of `third_party/coap/BUILD`.

OpenOCF uses the https://bazel.build/[Bazel] build system.

OpenOCF is written in the c-without-include-headers style made
possible by https://www.hwaci.com/sw/mkhdr/[makeheaders]. This
requires a preprocessing step as part of the build.

Prerequisites: Bazel, GNU autotools. On Windows: msys2, mingw-64.

WARNING: See notes below if you are building on Windows.

=== configuration

Start by configuring coap; see the comments in
`third_party/coap/BUILD` for instructions.

Then configure OpenOCF:

[source,sh]
----
$ automake --add-missing  # generates config.guess, config.sub (both required)
$ autoheader && autoconf
$ ./configure --enable-logging
----

Run `./configure --help` to see the `--enable-feature` and `--with-lib` options.

WARNING: Configuration support for cross-compiling is WIP.


=== building

Prep: first we construct the list of files to be processed by
makeheaders; this list varies by platform, so we use a Bazel target:

[source,sh]
----
$ bazel build :mkhdrs
----

This creates `./bazel-bin/mkhdrs.dat`. We process this to create our
headers. First build the makeheaders program:

[source,]
----
$ bazel build tools/makeheaders
----

The result will be `./bazel-bin/tools/makeheaders/makeheaders`. Since makeheaders is extremely unlikely to change, you can copy it to a directory on your path, e.g.

[source,sh]
----
$ cp ./bazel-bin/tools/makeheaders/makeheaders $HOME/bin
----

Now use it to produces the internal library headers, then the public
API exposed to application developers:

[source,sh]
----
$ ./bazel-bin/tools/makeheaders -f bazel-bin/mkhdrs.dat
$ ./bazel-bin/tools/makeheaders -f bazel-bin/mkhdrs.dat -H > include/openocf_h.h
----



Targets are defined by BUILD files; cross-compilation by flags. Before
building, see link:tools/bazel.rc[tools/bazel.rc] and make sure you've
got the right ones.  You can build any target.  Examples:

* `$ bazel build src/provisioning`
* `$ bazel build src/comm`
* etc

The main target for building OpenOCF for use by an application is
`//:openocf`. You can build it like so: `$ bazel build :openocf`.

Now build test apps:

[source,shell]
----
$ bazel build examples/discovery:server
$ bazel build examples/discovery:client
----

Output executables will be in `./bazel-bin/examples/discovery

This example has been built and tested on Ubuntu (16.04.3 LTS), macOS
Sierra (10.12.6), Windows 7, Raspberry Pi 3b, and Wind River Linux.


IMPORTANT: As you develop code, you will need to rerun makeheaders
whenever you make a change affecting the visibility of your code
(fortunately makeheaders is lightning-fast). For example, if you
change a function prototype or add code that refers to something in
another file. If you add or remove source files, you will also need to
rerun `$ bazel build :mkhdrs` before rerunning makeheaders. In the
future I hope to automate all this so a single bazel command will do
the all the right things.

==== windows

Prerequisites: mingw shell and GNU tools (autoheader, autoconf,
etc.). Recommend using http://www.msys2.org/[msys2]. Use pacman to
install needed packages.

IMPORTANT: Currently only the MSVC compiler is supported. That's the
default for Bazel builds.  Support for the Mingw GCC compiler is
almost complete but there are still a few unresolved bugs. Patches
welcome.

Libcoap (in `third_party/coap`) does not work with mingw64 out of the
box; it requires some patches that have not been submitted yet. Search
third_party/coap/src/coap_io.c for "GAR" to see what's needed.

Windows needs some special therapy.  Since we're using mingw-based
tools for feature test configuration but compiling with MSVC tools, we
get some false positives: headers that exist in the mingw environment
but not the MSVC environment. Specifically, the generated
`src/_openocf_config.h` file will #define the following:

HAVE_LIBPTHREAD
HAVE_PTHREAD_H
HAVE_STRINGS_H
HAVE_SYS_SOCKET_H
HAVE_SYS_TIME_H
TIME_WITH_SYS_TIME
HAVE_UNISTD_H
HAVE_SYS_UNISTD_H

These must be #undefined if compiling with the MSVC toolchain. As a
convenience we provide `src/_openocf_config_win.h` which you can copy
to `src/_openocf_config.h` instead of running `./configure`.

=== cross-compiling

See
https://github.com/mobileink/bazel-crosscompile[bazel-crosscompile]
for detailed examples of crosscompiling with Bazel. The relevant files
here are in link:platforms[platforms/] and link:WORKSPACE[WORKSPACE].

Summary:

1. Build/install the toolchain.

2. Configure the toolchain for Bazel (CROSSTOOL, etc.).

3. Build the third-party libs needed by your app.

4. Configure the third-party libraries for Bazel (WORKSPACE and BUILD files).

5. Configure your application (BUILD files).

6. Build using the toolchaing

Current support for cross-compiling is based on toolchains built by
https://crosstool-ng.github.io/[crosstool-NG].

NOTE: Building crosstool-NG toolchains requires a case-sensitive file
system. On OS X, you will have to create a disk image (dmg file) with
a case-sensitive filesystem. It's a bit of a pain but it works. See
https://www.jaredwolff.com/blog/cross-compiling-on-mac-osx-for-raspberry-pi/[Cross
Compiling on Mac OSX for Raspberry Pi], or search "crosstool-ng os x".

Once your toolchain is set up building is easy. For example, to target
the Raspberry Pi 3b:

[source,sh]
----
$ bazel build examples/simple:server --crosstool_top=//platforms/rpi3b:toolchain
----

See link:tools/bazel.rc[tools/bazel.rc]. Copy that file to `<root>/.bazelrc` to customize.


== Java/Android

See https://github.com/OpenOCF/iochibity-java[iochibity-java]


=== notes

https://ptspts.blogspot.com/2013/12/how-to-make-smaller-c-and-c-binaries.html

