= payload

OCF 2.0 section 12.1:

"All the property information from the resource model shall be carried
within the message payload. This payload shall be generated in the
resource model layer and shall be encapsulated in the data
connectivity layer. The message header shall only be used to describe
the message payload (e.g., verb, mime-type, message payload format),
in addition to the mandatory header fields defined in messaging
protocol (e.g., CoAP) specification. If the message header does not
support this, then this information shall also be carried in the
message payload. Resource model information shall not be included in
the message header structure unless the message header field is
mandatory in the messaging protocol specification."

However, an OCF message "payload" may be split across multiple CoAP
message payloads if BlockWise Transfer (BWT) is enabled; in this case,
the complete OCF message is called the "body" and each block is the
"payload" of a single CoAP message.  (RFC 7959, 8323)

OpenOCF (Iotivity) messages are CoAP messages; the processing logic
converts them into structs in which one field is a payload (OCF msg)
pointer. E.g. struct oocf_inbound_response.

Iotivity distinguishes between the following "types" of OCF messsage body:

* OCDiscoveryPayload - for responses to discovery requests. we call it oocf_oic_wk_res
* OCResourcePayload - for "links" in a discovery payload - we rename this OOCF_LinkPayload
* OCEndpointPayload - for the "eps" field of link payload. Not really a payload, just part of a payload
* OCRepPayload - for all other responses involving a resource "representation" (except SVRs)
* OCSecurityPayload - cbor encoded rep of an SVR e.g. oic/sec/doxm
* OCDiagnosticPayload
* OCIntrospectionPayload
* OCPresencePayload - obsolete?

Obsolete:  OCPlatformPayload, OCDevicePayload

Pragmatically, an OCF message body is a record of an observed
behavior, as opposed to a "representation" of a "resource".  (E.g. how
can "25 degrees centigrade" be construed as a representation of a
thermometer?)

NOTES

NB correspondance between "resource" and "payload". A "discovery
payload" is just an /oic/res (or oic.wk.res) record. A "security
payload" is just a cbor-encoded record of an SVR. A "representation
payload" is just a record of a user-defined resource.  Hence:

OCDiscoveryPayload =>  struct oocf_record_oic_wk_res
OCSecurityPayload =>  struct oocf_record_oic_sec_doxm, oocf_record_oic_sec_cred, etc.

device, platform resources: OCRepPayload => struct OCResource
user-defined resources: OCRepPayload => struct OCResource

In the case of SVRs we already have a struct, e.g. OicSecCred_t,
that's why we use cbor in the payload? But we don't have an oic.wk.res
struct - it's a dynamically generated list of links to hosted resource
structs. We only need a struct when processing a discovery request.

IOW, /oic/res is "the resource to enable discovery"; that's all it's
for. It need only be instantiated in response to discovery requests.

what about oic/d and oic/p? For those we do need to store info in a
structure.

OCSecurityPayload - why cbor content? why not do same for all payloads?

CBOR is the transfer syntax, it can encode any number of
properties. To decode it, though, we need a place to put the
properties - a c struct of some kind.  For each SVR, we have a routine
that decodes cbor to the appropriate c struct, e.g. CBORPayloadToCred,
which creates a OicSecCred_t for a cbor input.

Question: why not decode the cbor to create the inbound msg body as a
c struct, instead of leaving it to the app to do the decoding?

Question: why not use a generic struct with dynamic name-value
property map for SVRs, as we do for user-defined resources?  We could,
but that would be inefficient and cumbersome since the engine
frequently has to access the SVRs, e.g. for authorization logic.

The struct for user-defined resources is OCResource.

User-defined resources use dynamically allocated name-value map for
properties.

OBSOLETE notes:

== payload types:

=== payload.CoResourceLinks

OCDiscoveryPayload PAYLOAD_TYPE_DISCOVERY:        oic/res discovery result, list of resource links

Implemented as ? openocf.r.

=== payload.CoResourceLink

OCResourcePayload  : only found within OCDiscoveryPayload; contains resource metadata, excluding properties. compare OCResource

This corresponds to json link type (TODO: pull from spec)

typedef struct OCResourcePayload
{
    char* uri;			/* property "href" (mandatory) */
    char* rel;
    char* anchor; /* NB: for OIC 1.1, a transfer URI; for OCF 1.0, a OCF URI */
    OCStringLL* types;		/* property "rt" (mandatory) */
    OCStringLL* interfaces;	/* property "if" (mandatory) */
    uint8_t bitmap;		/* visibility policy bitmask: discoverable, observable */
    bool secure;    /* legacy; OCF 1.0 uses eps */
    uint16_t port;    /* legacy; OCF 1.0 uses eps */
#ifdef TCP_ADAPTER
    uint16_t tcpPort;
#endif
    struct OCResourcePayload* next;
    OCEndpointPayload* eps;  /* OCF 1.0 */
    /* GAR: what about the remaining optional parameters, e.g. di, type (mt?), etc. */
} OCResourcePayload;



=== Endpoint

Note that we have several "endpoint" structs:

ocf/ocendpoint.c:

typedef struct CAEndpoint_s
{
    CATransportAdapter_t    adapter;    // adapter type
    CATransportFlags_t      flags;      // transport modifiers
    uint16_t                port;       // for IP
    char                    addr[MAX_ADDR_STR_SIZE_CA]; // address for all
    uint32_t                ifindex;    // usually zero for default interface
    char                    remoteId[CA_MAX_IDENTITY_SIZE]; // device ID of remote device
#if defined (ROUTING_GATEWAY) || defined (ROUTING_EP)
    char                    routeData[MAX_ADDR_STR_SIZE_CA]; /**< GatewayId:ClientId of
                                                                    destination. **/
#endif
} CAEndpoint_t;

ocf/_protocol.h:
typedef struct
{
    OCTransportAdapter      adapter;
    OCTransportFlags        flags;
    uint16_t                port;
    char                    addr[MAX_ADDR_STR_SIZE];
    uint32_t                ifindex;
    char                    routeData[MAX_ADDR_STR_SIZE];
    char                    remoteId[MAX_IDENTITY_SIZE];
} OCDevAddr;

NOTE: "OCDevAddr must be the same as CAEndpoint (in CACommon.h)." But
routeData is not ifdef'ed in OCDevAddr, and the order is reversed.


ocf/ocpayload.c:

typedef struct OCEndpointPayload
{
    char* tps;
    char* addr;
    OCTransportFlags family;
    uint16_t port;
    uint16_t pri;
    struct OCEndpointPayload* next;
} OCEndpointPayload;

The difference: OCEndpointPayload does not contain an interface index, remote id, route

And we often have e.g. OCDevAddr *endpoint, and things like:

ocstack.c :: CopyDevAddrToEndpoint(const OCDevAddr *in, CAEndpoint_t *out)


OCEndpointPayload is used inside OCResourcePayload.

=== payload.CoResourceList

OCRepPayload PAYLOAD_TYPE_REPRESENTATION - resource representation
including properties. A linked list.

We drop the "representation" nonsense.

Note that a discovery payload is also a "representation" of the
/oic/res resource; it just has links instead of properties.

Recall: a resource can be anything, including a collection of other
resources. OCRepPayload is used for all except discovery payloads.


typedef struct OCRepPayload
{
    OCPayload base;
    char* uri;
    OCStringLL* types;
    OCStringLL* interfaces;
    OCRepPayloadValue* values;
    struct OCRepPayload* next;
} OCRepPayload;



=== payload.PlatformPayload

OCPlatformPayload PAYLOAD_TYPE_PLATFORM

=== payload.DevicePayload

OCDevicePayload PAYLOAD_TYPE_DEVICE

payload.presence???

OCPresencePayload PAYLOAD_TYPE_PRESENCE

=== payload.SVRPayload

Each security payload contains CBOR-encoded data for one SVR
(e.g. doxm, pstat, etc.).

OCClientResponse* message

message->payload->type === PAYLOAD_TYPE_SECURITY

If Message payload type is PAYLOAD_TYPE_SECURITY, then message->payload is a
struct OCSecurityPayload, and message->URI indicates which SVR is encoded
in the securityData field of the payload. Then use CBOR codec to
decode the binary into the appropriate SVR struct (e.g. OicSecDoxm_t):

if (starts_with("/oic/sec/doxm", message->resourceUri)) {
    OicSecDoxm_t *doxm_payload = NULL;
    OCStackResult r = CBORPayloadToDoxm(payload->securityData, payload->payloadSize, &doxm_payload);
    /* ... etc. ... */
}

see openocf/tools/browser/client/svrs_codec.c

NOTE: the SVR struct in an inbound payload is the same as used on the
server to represent the SVR state, e.g. OicSecDoxm_t. So we do not
want a payload-specific struct or class.  I.e. instead of
openocf.payload.DOXM, something like openocf.oic.sec.DOXM; this could
be used by both server and client.

We can wrap these in SVR classes, e.g. openocf.oic.sec.DOXM or similar,
instead of glomming everything into one Security class.

=== payload.Diagnostic

OCDiagnosticPayload PAYLOAD_TYPE_DIAGNOSTIC

Contains only a char *message;

=== payload.Introspection

OCIntrospectionPayload PAYLOAD_TYPE_INTROSPECTION

Contains only a OCByteString cborPayload;

=== obsolete

obsolete as of 1.3.1:  (?)

* OCRDDiscoveryPayload - Resource Directory discovery
* OCRDPayload          - Resource Directory
* OCResourceCollectionPayload - OCRepPayload is used for thise
* OCTagsPayload  - substruct used in OCResourceCollectionPayload
* OCLinksPayload - substruct used in OCResourceCollectionPayload
